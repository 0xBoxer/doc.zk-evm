---
title: Architecture of Linea
description: An overview of how Linea works
sidebar_position: 4
---

import bluecircle from '../../static/img/bluecircle.png'; import redcircle from '../../static/img/redcircle.png';

# The Shape of a Line: Linea's Architecture

<img src={bluecircle}  style={{width:200}}></img>

## Linea's ideal state

Linea has the goal of being a fully decentralized, permissionless network. To that end, we are building towards an architecture made up of three main elements:

- Sequencer
- Prover
- Bridge Relayer

(Don't worry, if this isn't making sense to you yet, we'll explain further below üòé)

## Current state

As Linea is still a beta testnet, and there's lots of development to be done, we're not quite there yet. Currently, the first two sections above are kind of rolled into one:

- Centralized Sequencer & Prover
- Bridge Relayer

> _Note: in general, we will be explaining Linea and its relationship to Ethereum. Linea is currently in beta testnet, so mentions to Ethereum should be understood to refer to either testnet Ethereum, if discussing the current state of the network, or mainnet Ethereum, if discussing a future state of development._

## First of all: what _is_ Linea, anyway? What's a zkEVM L2?

There are a number of different mental models that people in web3 use to explain these different networks and how they relate to one another. Some people prefer to call them "rollup networks", or "scaling solutions"; probably the most popular way of discussing them is by imagining them as "layers", where one network is "built on top of another". Let's try and set metaphor aside for a moment, and speak in clear terms:

**The Ethereum network has several functional areas:**

> - It has the _blockchain_, where it keeps track of addresses, and which tokens are allocated to which addresses.
> - It has the _consensus_ mechanism, wherein many many nodes communicate about the movement of tokens from one address to another, and each keeps their local copy of the ledger up to date.
> - And it has the _execution environment_, wherein computer programs can be run. That's the "EVM", or "Ethereum Virtual Machine", part of things.

**These three areas are heavily interconnected, and this is a simplification, but it's a helpful one to understand what's going on with other networks.**

Ethereum prioritizes security: that consensus mechanism is designed to ensure that no one can singlehandedly alter the state of the network. This is a very impressive feat of engineering, and it comes with a tradeoff: the execution environment is highly limited in the amount of work it can do, because the consensus mechanism intentionally runs slowly, to keep everything safe.

Linea, and other networks like it, is designed to participate in the security mechanism of Ethereum, while optimizing for execution. In other words, it allows people to do lots of transactions, run lots of programs, deploy contracts, mint NFTs, absolutely go to town--fast, and cheap--and then report all that back to Ethereum, and include it in Ethereum's blockchain. By sending regular reports of activity on Linea to Ethereum, the network can optimize for execution without being as limited by security.

This is the action known as "rolling up": we would say that Linea "rolls up its transactions to Ethereum". And the fact that it relies on Ethereum for something--the security--leads people to say that it's "built on top of Ethereum": it's a "second-layer network", an L2. And before you ask, yes, Ethereum is an L1, and L3s exist, too: networks that roll up to Linea would roll up to Ethereum...

The trick is in how that _rollup_ happens. Linea is special: it uses cutting-edge developments in a branch of mathematics and computer science often referred to as **zero-knowledge**, or _zero-knowledge cryptography_, to **prove to the Ethereum network that everything that is happening on the Linea network is, in fact, happening, without having to submit a complete record of every last transaction and check each one.** That's the 'zk' part.

So, now that we've walked through some concepts, we can roll it all up: **Linea is a zkEVM L2 network**.

### OK... But what's a _sequencer_ and a _prover_? How does all this actually work?

At a high level, if you were to follow a flow from Ethereum, through Linea, and back to Ethereum, it would go like this:

> #### Ethereum bridge contract >
>
> #### Linea bridge contract >
>
> #### Coordinator >
>
> #### Sequencer (Block building > Execution > Trace data generation) >
>
> #### Coordinator >
>
> #### Trace Conflation >
>
> #### EVM State Manager >
>
> #### Trace Expansion and Proving (Corset > gnark) >
>
> #### Coordinator >
>
> #### zk-proof and updated Merkle tree >
>
> #### Linea bridge contract >
>
> #### Ethereum bridge contract >
>
> #### Ethereum blockchain

_...in other words, there's a lot involved. _

### Simplifying things

In order to make this explanation as clear and navigable as possible, we'll break each component down, and explain it in three steps:

> #### What is it?
>
> #### What does it do?
>
> #### How does it do it?

Let's start with the thing that a lot of users encounter when trying to access an L2 for the first time: **a bridge**.

But not just any bridge; there are a lot of data to pass back and forth between Linea and other networks, and therefore, Linea has more than one bridge; and that number is likely to continue to grow. But there's one in particular that matters: the **Linea Canonical Message Service**.







## Other Functions: Network Data

### What is it?

One of the main value propositions of a public blockchain network is that it be, well, _public_. This means that the information about what‚Äôs going on the network needs to be readily available. Networks like Ethereum have this more or less built in and available as part of the software: each node has an API that will return any information you ask for; if you have a lot of requests, well, you just need more nodes.

To be clear, that‚Äôs how Linea works too‚Äìit‚Äôs just that Ethereum is decentralized and open; anyone can run a node. Linea is still a testnet, and its nodes are only being run by teams at Consensys. Therefore, in order to provide for the massive interest that the network has generated, a lot of nodes have to be run. This allows dapps to ask for information about the state of the network without impeding the actual execution of transactions by overloading the client.

### What does it do?

Receives and responds to requests from users and dapps according to the Ethereum JSON-RPC API standard. This includes providing information to MetaMask users about their accounts on Linea.

### How does it do it?

By leveraging the expertise and resources of Infura, Consensys, and the Ethereum ecosystem as a whole üòÄ Infura is running a number of nodes to provide this service, in two main capacities:

#### Client-facing RPC-API nodes

- These nodes do the ‚Äútraditional‚Äù work of EVM nodes: on the one hand, they are receiving updated network state information from the sequencer and state manager, and providing information about that state to users and dapps when they request it. On the other, they are receiving incoming transactions.
- All that traffic means that Infura is running them behind a load balancer, and bringing their expertise in scaling blockchain networks across the operation. Those transactions submitted by users are therefore balanced across the nodes, and are thereby routed into the memory pool, for subsequent ingestion and processing by the Coordinator and sequencer in zkBesu.

#### Archive Nodes

- There are more and more dapps and research activities being performed not just on current transaction data, but historical data as well‚Äìwhether from a day ago, last month, or three years ago (though not that long on Linea, yet!).
- This type of data request can be quite resource-intensive, and could put the live network nodes at risk of having their performance impacted, and thus threaten the overall health of the network. For this reason, Infura also has deployed archive nodes in a scalable architecture; these kinds of transactions aren‚Äôt being run _all_ the time, after all‚Äìbut when they are, more nodes are spun up as needed to keep up with demand.
