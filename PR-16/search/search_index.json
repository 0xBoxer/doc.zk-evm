{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.\\_]+"},"docs":[{"location":"","text":"ConsenSys zkEVM \u00b6 What is ConsenSys zkEVM? \u00b6 ConsenSys zkEVM is a type 2 zero knowledge Ethereum Virtual Machine (zkEVM). A zkEVM replicates the Ethereum environment as a rollup, and allows developers to build on it as they would on Ethereum mainnet. The ConsenSys zkEVM network allows you to deploy any smart contract, use any tool, and develop as if you\u2019re building on Ethereum. For users, this enables the experience and security guarantees of Ethereum, but with lower transaction costs. How do I join the private testnet? \u00b6 If you\u2019re interested in joining the private testnet, then join the waiting list . Dapp developers, users, researchers, and existing protocols are encouraged to join and help scale Ethereum. Once your wallet address is granted access, you\u2019ll be allowed to bridge funds (Goerli ETH) to the network and begin using it. Until then, please wait for an email to confirm that your account has access.","title":"ConsenSys zkEVM"},{"location":"#consensys-zkevm","text":"","title":"ConsenSys zkEVM"},{"location":"#what-is-consensys-zkevm","text":"ConsenSys zkEVM is a type 2 zero knowledge Ethereum Virtual Machine (zkEVM). A zkEVM replicates the Ethereum environment as a rollup, and allows developers to build on it as they would on Ethereum mainnet. The ConsenSys zkEVM network allows you to deploy any smart contract, use any tool, and develop as if you\u2019re building on Ethereum. For users, this enables the experience and security guarantees of Ethereum, but with lower transaction costs.","title":"What is ConsenSys zkEVM?"},{"location":"#how-do-i-join-the-private-testnet","text":"If you\u2019re interested in joining the private testnet, then join the waiting list . Dapp developers, users, researchers, and existing protocols are encouraged to join and help scale Ethereum. Once your wallet address is granted access, you\u2019ll be allowed to bridge funds (Goerli ETH) to the network and begin using it. Until then, please wait for an email to confirm that your account has access.","title":"How do I join the private testnet?"},{"location":"contact/provide-feedback/","text":"Provide feedback \u00b6 We would love to hear your feedback after you experimented with the ConsenSys zkEVM. Please fill out this form to let us know about your experience. Important Please only complete this form once you have been onboarded and have tested the network. For technical issues, please reach out to zkevm-feedback@consensys.net . Screenshots and transaction hashes will help us diagnose issues and improve the product. We may not be able to respond directly to issues.","title":"Provide feedback"},{"location":"contact/provide-feedback/#provide-feedback","text":"We would love to hear your feedback after you experimented with the ConsenSys zkEVM. Please fill out this form to let us know about your experience. Important Please only complete this form once you have been onboarded and have tested the network. For technical issues, please reach out to zkevm-feedback@consensys.net . Screenshots and transaction hashes will help us diagnose issues and improve the product. We may not be able to respond directly to issues.","title":"Provide feedback"},{"location":"contact/report-issues/","text":"Report an issue \u00b6 If you encounter any issues during testing, please contact zkevm-feedback@consensys.net to report an issue. The more information you provide the better: transaction ID, screenshots, and detailed steps taken to reproduce the issue will help resolve the issues quicker. You can also post your issue in the zkevm-rollup channel in the ConsenSys Discord .","title":"Report an issue"},{"location":"contact/report-issues/#report-an-issue","text":"If you encounter any issues during testing, please contact zkevm-feedback@consensys.net to report an issue. The more information you provide the better: transaction ID, screenshots, and detailed steps taken to reproduce the issue will help resolve the issues quicker. You can also post your issue in the zkevm-rollup channel in the ConsenSys Discord .","title":"Report an issue"},{"location":"developers/deploy-smart-contracts/","text":"Deploy a smart contract \u00b6 You can use the Truffle development framework to build, test, and deploy smart contracts on the ConsenSys zkEVM. Use the Truffle quickstart instructions to quickly start using Truffle with ConsenSys zkEVM. Important Ensure you change your RPC endpoint to https://consensys-zkevm-goerli-prealpha.infura.io/v3/<INFURA_API_KEY> in the truffle-config.js file. Alternatively, use the steps below to deploy a smart contract using Truffle. Prerequisites \u00b6 Install Truffle using the recommended installation procedure . You can use Truffle Dashboard for your deployment. Truffle Dashboard allows you to forgo saving your private keys locally, instead connecting to your MetaMask wallet for deployments. Follow these steps to set up Truffle Dashboard for use with the ConsenSys zkEVM: Configure your MetaMask wallet to connect to the ConsenSys zkEVM, using these instructions . Set your MetaMask network to the ConsenSys zkEVM. Run truffle dashboard in your CLI. A window on port 24012 will open. The Truffle Dashboard will ask you to confirm that your network is correct. For reference, the ConsenSys zkEVM testnet network id is 59140. Steps \u00b6 Create a project directory for your Truffle project. For example, myToken . mkdir myToken ; cd myToken In your project directory, create the bare project containing the files and directories for the Truffle project: truffle init Create your smart contract in the contracts directory. For example, to create a simple token contract, create a file called Token.sol in the contracts directory and add the following contract code: pragma solidity 0.8.17 ; // SPDX-License-Identifier: MIT contract Token { string public name = \"My Token\" ; string public symbol = \"MTK\" ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000 ; mapping ( address => uint256 ) public balances ; address public owner ; constructor () public { owner = msg . sender ; balances [ owner ] = totalSupply ; } function transfer ( address recipient , uint256 amount ) public { require ( balances [ msg . sender ] >= amount , \"Insufficient balance.\" ); balances [ msg . sender ] -= amount ; balances [ recipient ] += amount ; } } Do not use this contract code in production The above contract is for testing purposes and has not been audited. In the root of your project folder, compile the contract: truffle compile Create a migration script in the migrations directory to deploy and manage the contract on the ConsenSys zkEVM network. For example, to deploy the token contract, create a file called 1_deploy_token.js in the migrations directory, and add the following code: const Token = artifacts . require ( 'Token' ); module . exports = function ( deployer ) { deployer . deploy ( Token ); }; Truffle offers two ways of deploying your contracts: Truffle Dashboard: If you have set up Truffle Dashboard per the steps in the Prerequisites section above, deploying via the Truffle Dashboard simply requires triggering the deployment flow: In your CLI, run truffle migrate . You will see a signature request for each contract in the Truffle Dashboard. Confirm each request, and your contracts will deploy. Classic Truffle: Connect to the ConsenSys zkEVM testnet, by adding the following configuration to the truffle-config.js file: const HDWalletProvider = require ( '@truffle/hdwallet-provider' ) ... module . exports = { networks : { ... // for testnet 'consensys-goerli' : { provider : () => { return new HDWalletProvider ( MNEMONIC , 'https://consensys-zkevm-goerli-prealpha.infura.io/v3/INFURA_API_KEY' ) } network_id : \"59140\" } }, ... } Set your MNEMONIC and INFURA_API_KEY as environment variables. Important We recommend using a .env file for this purpose. Please do not check your keys into source control! Deploy your contracts by running truffle migrate --network=\"consensys-goerli\" .","title":"Deploy a smart contract"},{"location":"developers/deploy-smart-contracts/#deploy-a-smart-contract","text":"You can use the Truffle development framework to build, test, and deploy smart contracts on the ConsenSys zkEVM. Use the Truffle quickstart instructions to quickly start using Truffle with ConsenSys zkEVM. Important Ensure you change your RPC endpoint to https://consensys-zkevm-goerli-prealpha.infura.io/v3/<INFURA_API_KEY> in the truffle-config.js file. Alternatively, use the steps below to deploy a smart contract using Truffle.","title":"Deploy a smart contract"},{"location":"developers/deploy-smart-contracts/#prerequisites","text":"Install Truffle using the recommended installation procedure . You can use Truffle Dashboard for your deployment. Truffle Dashboard allows you to forgo saving your private keys locally, instead connecting to your MetaMask wallet for deployments. Follow these steps to set up Truffle Dashboard for use with the ConsenSys zkEVM: Configure your MetaMask wallet to connect to the ConsenSys zkEVM, using these instructions . Set your MetaMask network to the ConsenSys zkEVM. Run truffle dashboard in your CLI. A window on port 24012 will open. The Truffle Dashboard will ask you to confirm that your network is correct. For reference, the ConsenSys zkEVM testnet network id is 59140.","title":"Prerequisites"},{"location":"developers/deploy-smart-contracts/#steps","text":"Create a project directory for your Truffle project. For example, myToken . mkdir myToken ; cd myToken In your project directory, create the bare project containing the files and directories for the Truffle project: truffle init Create your smart contract in the contracts directory. For example, to create a simple token contract, create a file called Token.sol in the contracts directory and add the following contract code: pragma solidity 0.8.17 ; // SPDX-License-Identifier: MIT contract Token { string public name = \"My Token\" ; string public symbol = \"MTK\" ; uint8 public decimals = 18 ; uint256 public totalSupply = 100000000 ; mapping ( address => uint256 ) public balances ; address public owner ; constructor () public { owner = msg . sender ; balances [ owner ] = totalSupply ; } function transfer ( address recipient , uint256 amount ) public { require ( balances [ msg . sender ] >= amount , \"Insufficient balance.\" ); balances [ msg . sender ] -= amount ; balances [ recipient ] += amount ; } } Do not use this contract code in production The above contract is for testing purposes and has not been audited. In the root of your project folder, compile the contract: truffle compile Create a migration script in the migrations directory to deploy and manage the contract on the ConsenSys zkEVM network. For example, to deploy the token contract, create a file called 1_deploy_token.js in the migrations directory, and add the following code: const Token = artifacts . require ( 'Token' ); module . exports = function ( deployer ) { deployer . deploy ( Token ); }; Truffle offers two ways of deploying your contracts: Truffle Dashboard: If you have set up Truffle Dashboard per the steps in the Prerequisites section above, deploying via the Truffle Dashboard simply requires triggering the deployment flow: In your CLI, run truffle migrate . You will see a signature request for each contract in the Truffle Dashboard. Confirm each request, and your contracts will deploy. Classic Truffle: Connect to the ConsenSys zkEVM testnet, by adding the following configuration to the truffle-config.js file: const HDWalletProvider = require ( '@truffle/hdwallet-provider' ) ... module . exports = { networks : { ... // for testnet 'consensys-goerli' : { provider : () => { return new HDWalletProvider ( MNEMONIC , 'https://consensys-zkevm-goerli-prealpha.infura.io/v3/INFURA_API_KEY' ) } network_id : \"59140\" } }, ... } Set your MNEMONIC and INFURA_API_KEY as environment variables. Important We recommend using a .env file for this purpose. Please do not check your keys into source control! Deploy your contracts by running truffle migrate --network=\"consensys-goerli\" .","title":"Steps"},{"location":"developers/use-message-bridge/","text":"Build your dapp using the message bridge \u00b6 Use the ConsenSys zkEVM message bridge to bridge funds (in ETH) or arbitrary messages between Goerli and the ConsenSys zkEVM network to enable your use case. Important You can also just bridge funds . Overview \u00b6 The ConsenSys zkEVM message bridge operates using the following patterns. L1 \u2192 L2 \u00b6 The developer sends a transaction to the L1 bridge contract (implementing the IBridge.sol interface) on the dispatchMessage method. The L1 bridge contract emits a MessageDispatched event. The rollup relayer catches the event and sends an L2 transaction to the L2 bridge contract on the deliverMessage function. The L2 contract calls the contract defined in the to field. The L2 contract should authenticate the call by calling the sender() method on the L2 bridge upon reception of the deliverMessage call, and verifying that this corresponds to a known L1 address. The L1 bridge contract verifies the message execution, and emits an event MessageConfirmed , once the next L2 block is finalized and the ZK proof is verified. Otherwise, the developer can drop a message after the deadline , effectively reimbursing the value that was sent. L2 \u2192 L1 \u00b6 The four first steps are identical to L1 \u2192 L2 but in the opposite direction. The relayer embeds messages as a parameter when finalizing the block and verifying the ZK proof. Deployed contract addresses \u00b6 The contracts are deployed at the following addresses: The L1 bridge, implementing the IBridge.sol and IL1Bridge.sol interfaces, is located at 0xE87d317eB8dcc9afE24d9f63D6C760e52Bc18A40 . The L2 bridge, implementing the IBridge.sol interface, is located at 0xA59477f7742Ba7d51bb1E487a8540aB339d6801d . Interfaces \u00b6 IBridge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // SPDX-License-Identifier: OWNED BY ConsenSys Software Inc. pragma solidity ^ 0.8.15 ; /// @title The bridge interface implemented on both chains interface IBridge { /// @notice Emitted on the origin chain when a message is to be sent to the destination chain /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract /// @dev _calldata can be calculated using abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount)) event MessageDispatched ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes _calldata ); /// @notice Emitted on the destination chain when a message bas been received by the destination bridge /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract /// @dev _calldata can be calculated using abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount)) event MessageDelivered ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes _calldata ); /// @notice Dispatches a message from the given chain. Must be called by a developer or another contract. /// @notice If this is the L2 bridge, then this methods dispatches a message from L2 to L1. /// @dev This function should be called with a value > _fee. The reminder will be send on the destination chain. /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract function dispatchMessage ( address _to , uint256 _fee , uint256 _deadline , bytes calldata _calldata ) external payable ; /// @notice Deliver a message to the destination chain. /// @notice Is called automatically by the operator. Cannot be used by developers /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract function deliverMessage ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes calldata _calldata ) external payable ; /// @notice When called within the context of the delivered call can be used to return the sender (_from) /// @notice on the origin chain otherwise returns the zero address. /// @return Address of the caller contract on the origin chain. function sender () external view returns ( address ); } IL1Bridge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: OWNED BY ConsenSys Software Inc. pragma solidity ^ 0.8.15 ; import 'IBridge.sol' ; /// @title A specialization of the Bridge interface on the L1 interface IL1Bridge is IBridge { /// @notice Emitted when a message has been dispatched, delivered and is now confirmed on the original chain /// @param messageHash the hash of the message dispatched keccak256(abi.encode(from,to,fee,value,deadline,calldata)) event MessageConfirmed ( bytes32 messageHash ); /// @notice Drop a message that is past its deadline and refund the sender /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract /// @dev _calldata can be calculated using abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount)) function dropMessage ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes calldata _calldata ) external payable ; }","title":"Use the message bridge"},{"location":"developers/use-message-bridge/#build-your-dapp-using-the-message-bridge","text":"Use the ConsenSys zkEVM message bridge to bridge funds (in ETH) or arbitrary messages between Goerli and the ConsenSys zkEVM network to enable your use case. Important You can also just bridge funds .","title":"Build your dapp using the message bridge"},{"location":"developers/use-message-bridge/#overview","text":"The ConsenSys zkEVM message bridge operates using the following patterns.","title":"Overview"},{"location":"developers/use-message-bridge/#l1-l2","text":"The developer sends a transaction to the L1 bridge contract (implementing the IBridge.sol interface) on the dispatchMessage method. The L1 bridge contract emits a MessageDispatched event. The rollup relayer catches the event and sends an L2 transaction to the L2 bridge contract on the deliverMessage function. The L2 contract calls the contract defined in the to field. The L2 contract should authenticate the call by calling the sender() method on the L2 bridge upon reception of the deliverMessage call, and verifying that this corresponds to a known L1 address. The L1 bridge contract verifies the message execution, and emits an event MessageConfirmed , once the next L2 block is finalized and the ZK proof is verified. Otherwise, the developer can drop a message after the deadline , effectively reimbursing the value that was sent.","title":"L1 --&gt; L2"},{"location":"developers/use-message-bridge/#l2-l1","text":"The four first steps are identical to L1 \u2192 L2 but in the opposite direction. The relayer embeds messages as a parameter when finalizing the block and verifying the ZK proof.","title":"L2 --&gt; L1"},{"location":"developers/use-message-bridge/#deployed-contract-addresses","text":"The contracts are deployed at the following addresses: The L1 bridge, implementing the IBridge.sol and IL1Bridge.sol interfaces, is located at 0xE87d317eB8dcc9afE24d9f63D6C760e52Bc18A40 . The L2 bridge, implementing the IBridge.sol interface, is located at 0xA59477f7742Ba7d51bb1E487a8540aB339d6801d .","title":"Deployed contract addresses"},{"location":"developers/use-message-bridge/#interfaces","text":"IBridge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // SPDX-License-Identifier: OWNED BY ConsenSys Software Inc. pragma solidity ^ 0.8.15 ; /// @title The bridge interface implemented on both chains interface IBridge { /// @notice Emitted on the origin chain when a message is to be sent to the destination chain /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract /// @dev _calldata can be calculated using abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount)) event MessageDispatched ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes _calldata ); /// @notice Emitted on the destination chain when a message bas been received by the destination bridge /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract /// @dev _calldata can be calculated using abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount)) event MessageDelivered ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes _calldata ); /// @notice Dispatches a message from the given chain. Must be called by a developer or another contract. /// @notice If this is the L2 bridge, then this methods dispatches a message from L2 to L1. /// @dev This function should be called with a value > _fee. The reminder will be send on the destination chain. /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract function dispatchMessage ( address _to , uint256 _fee , uint256 _deadline , bytes calldata _calldata ) external payable ; /// @notice Deliver a message to the destination chain. /// @notice Is called automatically by the operator. Cannot be used by developers /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract function deliverMessage ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes calldata _calldata ) external payable ; /// @notice When called within the context of the delivered call can be used to return the sender (_from) /// @notice on the origin chain otherwise returns the zero address. /// @return Address of the caller contract on the origin chain. function sender () external view returns ( address ); } IL1Bridge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: OWNED BY ConsenSys Software Inc. pragma solidity ^ 0.8.15 ; import 'IBridge.sol' ; /// @title A specialization of the Bridge interface on the L1 interface IL1Bridge is IBridge { /// @notice Emitted when a message has been dispatched, delivered and is now confirmed on the original chain /// @param messageHash the hash of the message dispatched keccak256(abi.encode(from,to,fee,value,deadline,calldata)) event MessageConfirmed ( bytes32 messageHash ); /// @notice Drop a message that is past its deadline and refund the sender /// @param _from the msg.sender calling the origin bridge /// @param _to the destination contract on the destination chain /// @param _fee the bridge fee on the origin chain /// @param _value the value to be transferred /// @param _deadline timestamp as second since unix epoch after which the transaction is invalid and can be dropped /// @param _calldata the calldata used by the destination bridge to call the destination contract /// @dev _calldata can be calculated using abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount)) function dropMessage ( address _from , address _to , uint256 _fee , uint256 _value , uint256 _deadline , bytes calldata _calldata ) external payable ; }","title":"Interfaces"},{"location":"get-started/bridge-funds/","text":"Bridge your funds \u00b6 Use the ConsenSys zkEVM token bridge to bridge funds (in ETH) between Goerli and the ConsenSys zkEVM network. Important Do not bridge funds to the ConsenSys zkEVM network until you have been onboarded . Bridged funds will be inaccessible until you have been onboarded. Goerli to ConsenSys zkEVM \u00b6 Ensure your MetaMask wallet has ETH and is configured to use the ConsenSys zkEVM network. Perform the following steps to bridge your Goerli ETH to ConsenSys zkEVM: Access the bridge on the Goerli testnet. In the top dropdown menu select Goerli , and in the bottom dropdown menu select ConsenSys zkEVM . Select the USDC token. Specify an amount less than your balance to send. Select Send . Select Add USDC to MetaMask . In your MetaMask wallet, select ConsenSys zkEVM . You will see a balance for crUSDC. Select the ETH token. Specify an amount less than your balance to send. Select Send . Important First time users need to approve the ConsenSys zkEVM bridge to allow the transfer of your test ETH. In the MetaMask window, confirm the transfer. The sent amount is deducted from your Goerli account on MetaMask. Switch to the ConsenSys zkEVM network in your wallet to view the bridged funds. You can now use the funds on ConsenSys zkEVM to transfer funds between accounts or interact with smart contracts on the network. For example, use the Uniswap v3 protocol that\u2019s deployed on the network. Note This process can take up to 15 minutes to complete. ConsenSys zkEVM to Goerli \u00b6 Ensure that you added the ConsenSys zkEVM network to MetaMask and have Goerli ETH in your account on the ConsenSys zkEVM network. Perform the following steps to bridge your Goerli ETH from ConsenSys zkEVM to Goerli: Access the bridge on the Goerli testnet. In the top dropdown menu select ConsenSys zkEVM , and in the bottom dropdown menu select Goerli . Select the ETH token. Select Send . In the MetaMask window, confirm the transfer. The sent amount is deducted from your account on ConsenSys zkEVM. Switch to the Goerli network in your wallet to view the bridged funds. Note This process can take up to 5 mintues to complete.","title":"Bridge your funds"},{"location":"get-started/bridge-funds/#bridge-your-funds","text":"Use the ConsenSys zkEVM token bridge to bridge funds (in ETH) between Goerli and the ConsenSys zkEVM network. Important Do not bridge funds to the ConsenSys zkEVM network until you have been onboarded . Bridged funds will be inaccessible until you have been onboarded.","title":"Bridge your funds"},{"location":"get-started/bridge-funds/#goerli-to-consensys-zkevm","text":"Ensure your MetaMask wallet has ETH and is configured to use the ConsenSys zkEVM network. Perform the following steps to bridge your Goerli ETH to ConsenSys zkEVM: Access the bridge on the Goerli testnet. In the top dropdown menu select Goerli , and in the bottom dropdown menu select ConsenSys zkEVM . Select the USDC token. Specify an amount less than your balance to send. Select Send . Select Add USDC to MetaMask . In your MetaMask wallet, select ConsenSys zkEVM . You will see a balance for crUSDC. Select the ETH token. Specify an amount less than your balance to send. Select Send . Important First time users need to approve the ConsenSys zkEVM bridge to allow the transfer of your test ETH. In the MetaMask window, confirm the transfer. The sent amount is deducted from your Goerli account on MetaMask. Switch to the ConsenSys zkEVM network in your wallet to view the bridged funds. You can now use the funds on ConsenSys zkEVM to transfer funds between accounts or interact with smart contracts on the network. For example, use the Uniswap v3 protocol that\u2019s deployed on the network. Note This process can take up to 15 minutes to complete.","title":"Goerli to ConsenSys zkEVM"},{"location":"get-started/bridge-funds/#consensys-zkevm-to-goerli","text":"Ensure that you added the ConsenSys zkEVM network to MetaMask and have Goerli ETH in your account on the ConsenSys zkEVM network. Perform the following steps to bridge your Goerli ETH from ConsenSys zkEVM to Goerli: Access the bridge on the Goerli testnet. In the top dropdown menu select ConsenSys zkEVM , and in the bottom dropdown menu select Goerli . Select the ETH token. Select Send . In the MetaMask window, confirm the transfer. The sent amount is deducted from your account on ConsenSys zkEVM. Switch to the Goerli network in your wallet to view the bridged funds. Note This process can take up to 5 mintues to complete.","title":"ConsenSys zkEVM to Goerli"},{"location":"get-started/configure-metamask/","text":"Configure MetaMask \u00b6 Use the MetaMask wallet to interact with ConsenSys zkEVM. You can install MetaMask as a browser extension or mobile app . To configure MetaMask for the ConsenSys zkEVM network, go to the ConsenSys zkEVM Testnet Portal and follow the instructions on the drop-down labelled Testing Environment Setup . To retrieve your unique RPC URL: Sign in to your Infura account. Select Create new key . Select Web3 API for Network . Give your project a name, for example ConsenSys zkEVM . A card for ConsenSys zkEVM appears in your list of endpoints. Select the copy icon and paste the RPC URL into the testing environment setup found on our website . Important The ConsenSys zkEVM card only appears in your Infura dashboard after you have been allowlisted and have received the confirmation email. Add the ConsenSys zkEVM network manually to your MetaMask wallet using the following settings: Network Name : ConsenSys zkEVM New RPC URL : Paste your unique RPC URL endpoint which includes your API key for the ConsenSys zkEVM found within your Infura account Chain ID : 59140 Currency symbol : crETH Block explorer URL : https://explorer.goerli.zkevm.consensys.net You can also set up a custom network manually .","title":"Configure MetaMask"},{"location":"get-started/configure-metamask/#configure-metamask","text":"Use the MetaMask wallet to interact with ConsenSys zkEVM. You can install MetaMask as a browser extension or mobile app . To configure MetaMask for the ConsenSys zkEVM network, go to the ConsenSys zkEVM Testnet Portal and follow the instructions on the drop-down labelled Testing Environment Setup . To retrieve your unique RPC URL: Sign in to your Infura account. Select Create new key . Select Web3 API for Network . Give your project a name, for example ConsenSys zkEVM . A card for ConsenSys zkEVM appears in your list of endpoints. Select the copy icon and paste the RPC URL into the testing environment setup found on our website . Important The ConsenSys zkEVM card only appears in your Infura dashboard after you have been allowlisted and have received the confirmation email. Add the ConsenSys zkEVM network manually to your MetaMask wallet using the following settings: Network Name : ConsenSys zkEVM New RPC URL : Paste your unique RPC URL endpoint which includes your API key for the ConsenSys zkEVM found within your Infura account Chain ID : 59140 Currency symbol : crETH Block explorer URL : https://explorer.goerli.zkevm.consensys.net You can also set up a custom network manually .","title":"Configure MetaMask"},{"location":"get-started/fund/","text":"Fund your wallet \u00b6 Use MetaMask to store your funds and interact with the ConsenSys zkEVM network. You can install MetaMask as a browser extension or mobile app . You need to bridge Goerli ETH to the ConsenSys zkEVM network to interact with the network. Use a faucet to obtain Goerli ETH. Transactions are much cheaper than Mainnet, therefore 0.1 ETH is enough to execute a basic workflow. You can view a list of faucets for the Goerli network. To obtain test USDC on Goerli, use the USDC faucet using our bridge to mint 10 USDC. You must have some Goerli test ETH to pay for the transaction to mint USDC.","title":"Fund your wallet"},{"location":"get-started/fund/#fund-your-wallet","text":"Use MetaMask to store your funds and interact with the ConsenSys zkEVM network. You can install MetaMask as a browser extension or mobile app . You need to bridge Goerli ETH to the ConsenSys zkEVM network to interact with the network. Use a faucet to obtain Goerli ETH. Transactions are much cheaper than Mainnet, therefore 0.1 ETH is enough to execute a basic workflow. You can view a list of faucets for the Goerli network. To obtain test USDC on Goerli, use the USDC faucet using our bridge to mint 10 USDC. You must have some Goerli test ETH to pay for the transaction to mint USDC.","title":"Fund your wallet"},{"location":"get-started/onboarding-process/","text":"Onboarding process \u00b6 To ensure the system is secure and stable, we are gradually onboarding new users in the order signed up to the waitlist. The number of daily onboarded users vary, but we\u2019ll try to onboard everyone who signed up as quick as possible. Information You need an Infura account to access the ConsenSys zkEVM network. You can create your Infura account before or after joining the waitlist. The process to onboard to the ConsenSys zkEVM network is as follows: Join the waitlist . If you\u2019re an existing Infura user, use the same email address registered with Infura to simplify the onboarding process. Important If you\u2019re a registered Infura user who has opted out of receiving email communication, you\u2019ll receive a warning in the signup page saying, LOOKS LIKE YOU'VE OPTED OUT OF EMAIL COMMUNICATION. CLICK HERE TO GET AN EMAIL AND OPT BACK IN . We recommend you opt back in because you\u2019ll receive email communication from Infura when you\u2019ve been given network access. If you\u2019re a registered Infura user, you\u2019ll receive an Infura email confirming your place on the waiting list. If you\u2019re not a registered Infura user, you\u2019ll receive an email with the steps required to participate in the ConsenSys zkEVM private beta. You must create a free Infura account to be eligible for testing ConsenSys zkEVM. After you\u2019ve been onboarded you\u2019ll receive an email confirming access to ConsenSys zkEVM. This email provides instructions on how to access your unique RPC URL. You can now use the RPC URL in Infura to configure MetaMask and begin testing the network. Follow the testing environment setup to set up MetaMask and bridge funds to ConsenSys zkEVM to start testing. Note We recommend testing ConsenSys zkEVM on a desktop browser rather than tablet or mobile.","title":"Onboarding process"},{"location":"get-started/onboarding-process/#onboarding-process","text":"To ensure the system is secure and stable, we are gradually onboarding new users in the order signed up to the waitlist. The number of daily onboarded users vary, but we\u2019ll try to onboard everyone who signed up as quick as possible. Information You need an Infura account to access the ConsenSys zkEVM network. You can create your Infura account before or after joining the waitlist. The process to onboard to the ConsenSys zkEVM network is as follows: Join the waitlist . If you\u2019re an existing Infura user, use the same email address registered with Infura to simplify the onboarding process. Important If you\u2019re a registered Infura user who has opted out of receiving email communication, you\u2019ll receive a warning in the signup page saying, LOOKS LIKE YOU'VE OPTED OUT OF EMAIL COMMUNICATION. CLICK HERE TO GET AN EMAIL AND OPT BACK IN . We recommend you opt back in because you\u2019ll receive email communication from Infura when you\u2019ve been given network access. If you\u2019re a registered Infura user, you\u2019ll receive an Infura email confirming your place on the waiting list. If you\u2019re not a registered Infura user, you\u2019ll receive an email with the steps required to participate in the ConsenSys zkEVM private beta. You must create a free Infura account to be eligible for testing ConsenSys zkEVM. After you\u2019ve been onboarded you\u2019ll receive an email confirming access to ConsenSys zkEVM. This email provides instructions on how to access your unique RPC URL. You can now use the RPC URL in Infura to configure MetaMask and begin testing the network. Follow the testing environment setup to set up MetaMask and bridge funds to ConsenSys zkEVM to start testing. Note We recommend testing ConsenSys zkEVM on a desktop browser rather than tablet or mobile.","title":"Onboarding process"},{"location":"get-started/quickstart/","text":"Quickstart \u00b6 The following recommended workflow will help you get started testing the ConsenSys zkEVM testnet: Fund your wallet with Goerli ETH . Add ConsenSys zkEVM to your MetaMask wallet . Bridge from Goerli to ConsenSys zkEVM . Transfer funds between accounts on ConsenSys zkEVM . Use the Uniswap v3 fork to swap tokens and provide liquidity. View the status of your transactions in a block explorer . Bridge funds from ConsenSys zkEVM back to Goerli . Note The workflow above is a recommendation, but you are free to test the network however you want.","title":"Quickstart"},{"location":"get-started/quickstart/#quickstart","text":"The following recommended workflow will help you get started testing the ConsenSys zkEVM testnet: Fund your wallet with Goerli ETH . Add ConsenSys zkEVM to your MetaMask wallet . Bridge from Goerli to ConsenSys zkEVM . Transfer funds between accounts on ConsenSys zkEVM . Use the Uniswap v3 fork to swap tokens and provide liquidity. View the status of your transactions in a block explorer . Bridge funds from ConsenSys zkEVM back to Goerli . Note The workflow above is a recommendation, but you are free to test the network however you want.","title":"Quickstart"},{"location":"how-to/","text":"How to \u00b6 This section describes how to perform tasks on the ConsenSys zkEVM testnet.","title":"How to perform common tasks"},{"location":"how-to/#how-to","text":"This section describes how to perform tasks on the ConsenSys zkEVM testnet.","title":"How to"},{"location":"how-to/transfer-funds/","text":"Transfer funds between accounts \u00b6 You can use your MetaMask wallet to transfer funds between accounts in the ConsenSys zkEVM network. To do this: Open MetaMask and select ConsenSys zkEVM from the network drop-down Select Send . Type the address that you want to transfer funds to, or select Transfer between my accounts if the account belongs to your wallet. Type the amount to transfer and select Next , and select Confirm to send the transaction. You can now view the transaction details in the Activity tab or block explorer .","title":"Transfer funds between accounts"},{"location":"how-to/transfer-funds/#transfer-funds-between-accounts","text":"You can use your MetaMask wallet to transfer funds between accounts in the ConsenSys zkEVM network. To do this: Open MetaMask and select ConsenSys zkEVM from the network drop-down Select Send . Type the address that you want to transfer funds to, or select Transfer between my accounts if the account belongs to your wallet. Type the amount to transfer and select Next , and select Confirm to send the transaction. You can now view the transaction details in the Activity tab or block explorer .","title":"Transfer funds between accounts"},{"location":"how-to/use-uniswap/","text":"Use Uniswap \u00b6 The ConsenSys zkEVM testnet includes a fork of the Uniswap v3 protocol. Use the Uniswap app to swap tokens or add liquidity.","title":"Use Uniswap v3"},{"location":"how-to/use-uniswap/#use-uniswap","text":"The ConsenSys zkEVM testnet includes a fork of the Uniswap v3 protocol. Use the Uniswap app to swap tokens or add liquidity.","title":"Use Uniswap"},{"location":"how-to/use-uniswap/add-liquidity/","text":"Add liquidity \u00b6 To add liquidity to Uniswap v3 on ConsenSys zkEVM: Select the ConsenSys zkEVM network in your MetaMask wallet. Connect your wallet to the app. Click Connect wallet and select MetaMask . Your wallet address will appear in the top-right corner. Select the Pool tab. Select the pair of tokens you want to add liquidity for. Enter the amount you want to use for each token. Important If this is the first time adding liquidity, you\u2019ll need to approve the pool. Click Supply and check the details. Click the Confirm Supply to confirm and approve the transaction.","title":"Add liquidity"},{"location":"how-to/use-uniswap/add-liquidity/#add-liquidity","text":"To add liquidity to Uniswap v3 on ConsenSys zkEVM: Select the ConsenSys zkEVM network in your MetaMask wallet. Connect your wallet to the app. Click Connect wallet and select MetaMask . Your wallet address will appear in the top-right corner. Select the Pool tab. Select the pair of tokens you want to add liquidity for. Enter the amount you want to use for each token. Important If this is the first time adding liquidity, you\u2019ll need to approve the pool. Click Supply and check the details. Click the Confirm Supply to confirm and approve the transaction.","title":"Add liquidity"},{"location":"how-to/use-uniswap/swap/","text":"Swap tokens \u00b6 You can swap a portion of your funds to provide liquidity for a token pair. To swap tokens using Uniswap v3 on ConsenSys zkEVM : Select the ConsenSys zkEVM network in your MetaMask wallet. Connect your wallet to the app. Click Connect wallet and select MetaMask . Your wallet address will appear in the top-right corner. Select the Swap tab. Enter the tokens that you want to swap. Enter the amount you want to swap. Important If this is the first time swapping this token, you\u2019ll need to approve the swap. Select Swap and check the details. Confirm the swap by selecting Confirm Swap . Next you can use your token pairs to provide liquidity to a Uniswap pool.","title":"Swap tokens"},{"location":"how-to/use-uniswap/swap/#swap-tokens","text":"You can swap a portion of your funds to provide liquidity for a token pair. To swap tokens using Uniswap v3 on ConsenSys zkEVM : Select the ConsenSys zkEVM network in your MetaMask wallet. Connect your wallet to the app. Click Connect wallet and select MetaMask . Your wallet address will appear in the top-right corner. Select the Swap tab. Enter the tokens that you want to swap. Enter the amount you want to swap. Important If this is the first time swapping this token, you\u2019ll need to approve the swap. Select Swap and check the details. Confirm the swap by selecting Confirm Swap . Next you can use your token pairs to provide liquidity to a Uniswap pool.","title":"Swap tokens"},{"location":"reference/","text":"zk-EVM reference \u00b6","title":"zk-EVM reference"},{"location":"reference/#zk-evm-reference","text":"","title":"zk-EVM reference"},{"location":"reference/api/","text":"JSON-RPC API \u00b6 ConsenSys zkEVM uses the Ethereum JSON-RPC API . This is because the zkEVM is EVM-equivalent, meaning that the developer experience is identical to building on Ethereum itself.","title":"JSON-RPC API"},{"location":"reference/api/#json-rpc-api","text":"ConsenSys zkEVM uses the Ethereum JSON-RPC API . This is because the zkEVM is EVM-equivalent, meaning that the developer experience is identical to building on Ethereum itself.","title":"JSON-RPC API"},{"location":"reference/blockchain-explorer/","text":"Blockchain explorer \u00b6 ConsenSys zkEVM uses BlockScout as a block explorer, which has become standard across rollups.","title":"Blockchain explorer"},{"location":"reference/blockchain-explorer/#blockchain-explorer","text":"ConsenSys zkEVM uses BlockScout as a block explorer, which has become standard across rollups.","title":"Blockchain explorer"}]}